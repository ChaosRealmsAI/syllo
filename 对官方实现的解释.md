
  🏠 把拖拽编辑器想象成"整理房间"

  1. 拖拽句柄 = 家具把手

  现实生活中：
  - 你想移动一个重柜子，但柜子光滑难抓
  - 所以柜子两边装了把手，方便你抓住拖动
  - 把手会"跟着"柜子移动，始终在合适的位置

  编辑器中：
  - 文章段落就像"柜子"，普通情况下你抓不住
  - 拖拽句柄就是给每个段落装的"把手"
  - 鼠标移到段落旁边，"把手"就自动出现在合适位置

  2. 智能定位 = GPS导航

  现实生活中：
  - 你开车时，GPS会实时跟踪你的位置
  - 根据道路情况，自动调整最佳路线
  - 实时更新，永远知道你在哪里

  编辑器中：
  - 鼠标就像"汽车"，在文档里移动
  - 系统实时跟踪鼠标位置，找到最近的段落
  - 自动计算最佳的"把手"显示位置

  3. 纵向排列 = 整理书架

  现实生活中：
  - 书架上有很多本书（段落）
  - 你想重新排列几本书的顺序
  - 你会：
    a. 选择要移动的书（可能是连续的几本）
    b. 拿起这几本书作为一个整体
    c. 放到新的位置，其他书自动让位

  编辑器中：
  原来：📗📘📙📔📕
  选择：📗📘📙 (选中前三本)
  拖动：    📗📘📙 -> 放到这里
  结果：📔📕📗📘📙 (自动重新排列)

  4. 范围选择 = 打包搬家

  现实生活中：
  - 搬家时，你不会一本书一本书地搬
  - 而是把相关的书放在一个箱子里一起搬
  - 比如：所有小说放一箱，所有教科书放一箱

  编辑器中：
  - 系统智能识别"相关内容"（比如一个章节的所有段落）
  - 拖动时，会把相关的段落作为一个整体移动
  - 就像打包好的箱子，保持内部结构不变

  5. 协作编辑 = 多人搬家

  现实生活中：
  - 多个朋友帮你搬家
  - A在楼上整理，B在楼下接应
  - 需要实时沟通："我刚搬走了书架"，"好的，我这边更新了"

  编辑器中：
  - 多个用户同时编辑同一文档
  - 用户A拖动了段落，用户B的屏幕要立即同步更新
  - 系统像"对讲机"一样，实时同步每个人的操作

  6. 性能优化 = 省力技巧

  现实生活中：
  - 搬重物时，你不会每走一步都重新计算路线
  - 而是提前规划，一口气搬到位
  - 用推车、滑轮等工具省力

  编辑器中：
  - 不是鼠标每动一像素就重新计算
  - 而是"攒一下"，统一处理（requestAnimationFrame）
  - 用各种技巧避免卡顿，让拖拽更流畅

  🎯 核心理念

  这整个系统就像一个智能搬家助手：
  - 自动识别你想移动什么
  - 智能打包相关内容
  - 流畅搬运到新位置
  - 实时同步给所有合作者

  简单来说：让拖动文档内容像在桌面上移动文件夹一样自然！


⏺ 🔄 拖拽重排的完整实现过程 - 生活化解释

  基于源码分析，让我用搬家公司的完整流程来解释重排机制：

  1. 🎯 准备阶段 - 拖拽开始 (dragStart)

  现实中：
  - 你指着一个书架说："我要搬这个"
  - 搬家工人给书架贴上标签，记录原位置
  - 准备搬运工具和包装材料

  代码中：
  // dragHandler.ts:47-102
  function dragStart(e, view) {
    // 1. 找到要拖的内容
    const coords = { left: e.clientX, top: e.clientY }
    const pos = blockPosAtCoords(coords, view)

    // 2. "贴标签" - 创建选择
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos)))

    // 3. "打包" - 提取内容
    const slice = view.state.selection.content()

    // 4. "登记搬运清单" - 设置拖拽状态
    view.dragging = { slice, move: true }
  }

  2. 🚚 运输阶段 - 拖拽过程中

  现实中：
  - 搬家工人抬着书架在房间里移动
  - 其他人看到有东西在移动，暂时让出空间
  - 实时观察目标位置，准备接收

  代码中：
  // ProseMirror 自动处理拖拽显示
  e.dataTransfer?.setDragImage(dragElement, 0, 0)  // 拖拽时的视觉效果
  view.dragging = { slice, move: true }             // 告诉系统"正在搬运中"

  3. 📍 定位阶段 - 确定放置位置

  现实中：
  - 搬家工人问："放在这里吗？"
  - 你指着地面说："就这个位置"
  - 测量空间，确保能放下

  代码中：
  // 鼠标移动时实时计算目标位置
  const dropPos = view.posAtCoords({ left: e.clientX, top: e.clientY })

  // 计算插入点，确保位置合法
  const insertPos = dropPos ? dropPos.pos : null

  4. 🔄 重排核心 - handleDrop 真正的魔法！

  这是最关键的部分，让我用自动重新装修房间来解释：

  现实中的智能重排：
  原来房间： [沙发] [茶几] [书架] [电视]
  拖拽：     拿起 [书架]
  投放位置： 要放到 [沙发] 和 [茶几] 之间

  智能重排系统开始工作：
  1. "分析师"：计算新的布局方案
  2. "规划师"：制定移动步骤
  3. "工人们"：执行重新摆放
  4. "验收员"：检查最终效果

  结果房间： [沙发] [书架] [茶几] [电视]

  代码中的实际实现：

  // handleDrop 的核心逻辑（ProseMirror内部）
  handleDrop(view, event, slice, moved) {
    // 1. 【分析师】- 计算插入位置
    const dropPos = view.posAtCoords({
      left: event.clientX,
      top: event.clientY
    })

    // 2. 【规划师】- 创建文档变换事务
    const tr = view.state.tr

    if (moved) {
      // 这是移动（不是复制）

      // 3. 【工人A】- 先"删除"原位置的内容
      tr.deleteSelection()

      // 4. 【工人B】- 在新位置"插入"内容  
      tr.insert(dropPos.pos, slice.content)
    } else {
      // 这是复制
      tr.insert(dropPos.pos, slice.content)
    }

    // 5. 【验收员】- 提交变更，重新渲染界面
    view.dispatch(tr)
  }

  5. ⚡ 事务系统 - 确保原子性操作

  现实中：
  - 搬家必须"要么全部完成，要么全部回滚"
  - 不能出现"书架搬走了，但新位置还没放下"的情况
  - 如果搬家过程出错，必须恢复到原来的状态

  代码中：
  // Transform事务系统确保操作的原子性
  const tr = view.state.tr  // 创建事务

  // 在事务中进行所有操作
  tr.deleteSelection()       // 删除原内容
  tr.insert(newPos, content) // 插入新位置
  tr.setSelection(newSel)    // 更新光标位置

  // 一次性提交所有变更
  view.dispatch(tr)  // 要么全部成功，要么全部失败

  6. 🎨 视觉反馈 - 用户看到的效果

  现实中：
  - 搬家过程中，房间看起来是连续变化的
  - 没有"瞬间消失再瞬间出现"的感觉
  - 平滑的移动轨迹

  代码中：
  // 1. 拖拽时显示半透明的拖拽图像
  e.dataTransfer.setDragImage(clonedElement, 0, 0)

  // 2. 目标位置显示插入光标
  // (dropcursor插件处理)

  // 3. 放下时平滑过渡
  // DOM自动处理重新布局

  🎯 总结：重排的本质

  重排就像一个智能搬家机器人：

  1. 🤖 感知：知道你想移动什么
  2. 🧠 分析：计算最佳的新布局
  3. ✂️ 剪切：安全地"取出"原内容
  4. 📍 定位：找到合适的新位置
  5. 🔧 插入：将内容放入新位置
  6. 🎨 渲染：更新界面显示
  7. ✅ 完成：确保整个过程的一致性

  核心技术：
  - 事务系统：确保操作原子性
  - 位置计算：精确的坐标转换
  - 内容序列化：安全的数据传输
  - DOM 同步：高效的界面更新

  就像搬家公司有一套标准化流程，确保家具安全、高效地从一个位置移动到另一个位置！
